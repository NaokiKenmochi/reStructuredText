NumPy/SciPyを用いた実験データ解析
==================================
それでは，プラズマ実験で得られた実際のデータにたいして，NumPy/SciPyによる解析をしてみましょう．
ここでは，東京大学が所有する磁気圏型プラズマ装置RT-1において得られた3視線のマイクロ波干渉計のデータを例にします．

配列の生成
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
まずは実験データを読み込んでnumpyの配列を生成します．
NumPyではテキスト形式の読み込みにnp.loadtxtを使用します．

.. ipython:: python
    
    import matplotlib.pyplot as plt

.. ipython:: python

    IF = np.loadtxt("IF_20170608_74_raw.txt", delimiter=',')
    plt.plot(IF)
    plt.show()

テキスト形式での読み書きには，以下の特徴があります．

* 他のアプリケーションと互換性のある.dat, .csv, .txt形式のファイルの読み書きができる
* 保存できる配列の次元は２次元まで

次に，この配列に時間軸を作ることを考えます．
RT-1のマイクロ波干渉計では，サンプル周波数10 kHz，
データ収集は0.5秒から4.5秒まで行っています．
時間軸のような等差数列の生成には，np.arrangeやnp.linespaceを使用します．

.. ipython:: python
    
    sampling_time = 1.0e-4
    delay = 0.5
    sample_length = 4
    time = np.arange(delay, delay+sample_length, sampling_time, dtype=np.float)

    plt.plot(time, IF[:, 0])
    plt.plot(time, IF[:, 1])
    plt.show()

np.arangeは，連番や等差数列を生成します．
使い方はPythonの組み込み関数rangeと似ており，以下のように引数を取ります．
なお，[]で囲んだ引数は省略できるということを意味します．

``arange([start,] stop, [step,][, dtype])``

startで指定した数からstopで指定した数まで，step間隔の数字列を生成します．
第２引数stop以外は省略ができますが，第３引数stepを指定するときは同時に第１引数startも設定する必要があります．
なお，第２引数stopだけを指定した場合は，初項0で交差1の等差数列を要素とするndarrayを生成します．

np.linspaceは等差数列を生成する関数です．
同様の関数として先程紹介したnp.arangeがありますが，np.linspaceを使用すると指定した区間をN等分した配列を生成しているということが明確になります．

``linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)``

の形で使用し，生成する等差数列の始点と終点をstartとstopで指定します．
第３引数numで配列の長さを，第４引数endpointで終点を配列の要素として含むかどうかを指定します．

要素・行・列の取り出し
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
データを読み込んで配列が生成できたところで，計測信号の較正値を適応してみます．

インデキシング
------------------------
NumPyでは，インデキシング(indexing)という処理により，配列の任意の要素・行・列を切り出すことができます．
ただし，切り出し方によりコピーを生成するかビュー（参照）を生成するかという違いがありますので注意が必要です．

2章で紹介したように，Pythonのリストやタプルにも実装されているスライシング(slicing)をndarrayに対して行うと，その部分配列がビュー（参照）として返ってきます．
つまり，その部分配列はデータの一部のコピーではなく，部分配列に対する変更はオリジナルのndarrayを変更するということです．

この例では，arr_sliceはビューですので，arr2dに変更が反映されています．
他の配列指向の言語ではスライスのようなデータ片はコピーとして生成する仕様のものが多いため，このインデキシングの仕様に驚く方は多いと思います．
NumPyの目的の一つは大量データ処理ですが，ビューを生成することで元のndarrayのコピーがメモリ上に作成されないため，大きなデータを保持するndarrayのビューを生成してもメモリの使用量はそのビューを保持する分しか増えないというメリットがあります [#]_ ．

NumPyではndarrayで表現した行列に対して，行列の和・積，逆行列の計算，行列式の計算，固有値計算などさまざまな計算を行うメソッドや関数が用意されています．
行列計算では，ndarrayの ``+`` （和）， ``-`` （差）， ``*`` （積）， ``/`` （除算）， ``**`` （べき乗）， ``//`` （打ち切り除算）， ``%`` （剰余）は要素同士の計算になるという点に注意が必要です．
行列積を計算するには， ``dot`` メソッドを使うか， ``@`` 演算子（Python3.5以上かつNumPy1.10以上）を使う必要があります．

ブロードキャスティング
------------------------
``+-*/`` 等の四則演算や，ユニバーサル関数を使ってndarray同士の演算を行う際に，異なるサイズの２つのndarrayを使って計算を行わなければならないことがあります．
そのような状況で，処理の効率化のためにNumPyが備える配列演算の拡張ルールであるブロードキャスティング(Broadcasting)により，配列の形状を合わせて効率的に処理を行うのが計算を行える場合があります．

.. ipython:: python
    
    a1 = -0.005
    a2 = 0.000
    b1 = 0.135
    b2 = 0.300
    
    IF[:, 0] = np.arcsin((IF[:, 0]-a1)/b1)*180/np.pi
    IF[:, 1] = np.arcsin((IF[:, 1]-a2)/b2)*180/np.pi
    
    IF -= np.mean(IF[:5000, :], axis=0)

    IF = IF*5.58/360

    plt.plot(time, IF[:, 0])
    plt.plot(time, IF[:, 1])
    plt.show()


配列の演算
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
時系列データの配列が完成したら，ようやく解析になります．
時間発展スペクトルを調べてみます．

.. ipython:: python
    
    import scipy.signal as sig
    f, t, Pxx = sig.spectrogram(IF[:, 0], fs=1/sampling_time, window='hamming', nperseg=250)
    plt.pcolormesh(t, f, np.abs(Pxx), vmin=0, vmax=1e-2)
    plt.show()

最後に，物理量に変換した配列を時間軸と一緒にテキスト形式で保存します．

.. ipython:: python

    time_IF = np.zeros((len(time), 3))
    time_IF[:, 0] = time
    time_IF[:, 1:3] = IF
    np.savetxt('time_IF.txt', time_IF, delimiter=',')

まず、多チャンネル時系列データ扱うことを想定します。実際は2-3チャンネルで良いと思います。
PANTAの多チャンネルデータをsampleにしても良いです。

"配列の生成”ではまずloadtxtの説明から入るのが良いと思います。
次にこの配列に時間軸を作ることを想定します。(ファイルに時間軸もある場合も多いですが)
sampling_timeとdelayが分かっていた場合、arrange, linespaceを使って時間軸をどうやって作るか示します。

"要素・行・列の取り出し”と"配列の演算"では各信号の較正を例にとります。
プラズマがない時間帯をwhereで抜き出し、各チャンネルごと平均を取ってoffsetを求めます。
ここでindexing, copy, viewの説明をします。
次に各チャンネルからoffsetを引いてcalibration_factorを掛けます。
ここで配列演算とブロードキャスティングを説明します。

時系列データの配列が完成したらようやく解析になりますが、ここはあまり詳しくしなくても
良いでしょう。例えば時間発展スペクトルが見たければ
f, t, Pxx = spectrogram(x[istart:iend,...], fs=1.0/dt, window=window, nperseg=nfft, noverlap=noverlap, nfft=nfft, detrend=detrend,
                                  return_onesided=True, scaling='density', axis=0, mode='psd’)
で出来ます程度良いのでは？

最後に物理量に変換した配列を時間軸と一緒にsavetxtで保存する、という流れではいかがでしょうか。

個人的には、機能を網羅するというよりは、
初心者でもトレースできるコード例を先に示して、
それを説明することで「（CとかFortranだったら面倒だった）こんなことが簡単にできるんですよ」というのがアピールできる
というスタイルがいいような気がしています。

コード例を以下のようなシンプルなものにするのはどうでしょうか

1. とりあえず適当な実データを置いておいて np.loadtxt などで行列を作る（配列の確保）
　（適切なデータがなければ、3章の私の部分で使おうと思っているLHDトムソンのデータを使っても良いかもしれません。
　　データのアップロードについては私がNIFSと調整します。）
2. 要素の選択や代入について紹介する（インデクシング・スライス）
3. 行列全体に対する要素演算を紹介する（ブロードキャスト）
4. FFT や行列積など、ndarray全体に対して行う操作を紹介する

そして各項目の中で、その他の内容についても紹介する、というような感じにすればどうでしょうか。
例えば、
1の例ではファイルから読みだしたが、その他にも np.linspace, np.arange などがあってそれらは…とか
2の例では行列×スカラーのみ考えたが、行列×ベクトルの場合は…とか
